<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chain Reaction — Neon (Online)</title>
<style>
:root{ --text:#eaf2ff; --muted:#9fb3c8; --gap:10px; --cell-size:min(8.8vmin,56px); --radius:16px; }
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; color:var(--text);
  font:500 16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans";
  background: radial-gradient(1200px 800px at 10% 10%, #061126 0%, #070c18 40%, #050811 68%, #03060d 100%);
}
/* Topbar */
.topbar{ position:sticky; top:0; z-index:10; display:flex; gap:12px; align-items:center; justify-content:space-between;
  padding:12px clamp(12px, 3vw, 24px); background:rgba(5,8,17,.65); border-bottom:1px solid #ffffff16; backdrop-filter: blur(10px); }
.brand{font-weight:800; letter-spacing:.3px}
.controls{display:flex; flex-wrap:wrap; align-items:center; gap:8px 12px}
label{display:flex; align-items:center; gap:6px; color:var(--muted); font-size:14px}
select,.btn,input[type="text"]{ background:#121a2f; color:var(--text); border:1px solid #ffffff26; border-radius:12px; padding:8px 10px; cursor:pointer }
.btn:hover{background:#1b2748}

/* Color panel */
.colors{ display:flex; flex-wrap:wrap; align-items:center; gap:10px 14px; padding:10px 12px; margin:10px auto 0;
  border:1px solid #ffffff16; border-radius:14px; background:rgba(10,14,28,.6); backdrop-filter: blur(8px); }
.colors .row{display:flex; align-items:center; gap:10px}
.swatch{ display:flex; align-items:center; gap:8px; padding:6px 8px; border-radius:10px; background:#0e1630; border:1px solid #ffffff14; }
.swatch .dot{width:16px; height:16px; border-radius:999px; box-shadow:0 0 10px currentColor}
.swatch label{color:#cfe0ff; font-size:13px}
input[type="color"]{appearance:none; -webkit-appearance:none; width:36px; height:28px; border:none; background:transparent; cursor:pointer}
input[type="color"]::-webkit-color-swatch-wrapper{padding:0}
input[type="color"]::-webkit-color-swatch{border:none; border-radius:8px}

/* Layout */
.wrap{max-width:1150px; margin:0 auto; padding:16px clamp(12px, 3vw, 24px)}
.status{display:flex; align-items:center; gap:12px; margin:8px 0 16px}
.badge{min-width:14px; min-height:14px; border-radius:999px; border:2px solid #ffffff66; box-shadow:0 0 0 3px #ffffff22 inset}
.status-text{color:var(--muted); font-size:15px}
.row{display:flex; flex-wrap:wrap; align-items:center; gap:8px 10px; margin:10px 0}

/* Board */
.board{ position:relative; display:grid; gap:var(--gap); justify-content:center; padding:calc(var(--gap) + 4px);
  border-radius:20px; border:1px solid #ffffff18;
  background: radial-gradient(600px 400px at 20% 0%, #1a2a55 0%, #111d3b 35%, #0b132a 60%, #090f22 100%), linear-gradient(180deg,#0a1227,#0a0f1f);
  box-shadow: 0 0 0 1px #7aa7ff0e inset, 0 0 30px #1a2a5522 inset, 0 30px 80px #0009; overflow:hidden; }
.board::after{ content:""; position:absolute; inset:0;
  background: radial-gradient(500px 300px at var(--x,10%) var(--y,10%), #3b82f620 0%, transparent 60%), radial-gradient(400px 260px at calc(100% - var(--x,10%)) calc(100% - var(--y,10%)), #22d3ee18 0%, transparent 65%);
  mix-blend-mode:screen; animation: drift 10s linear infinite; pointer-events:none; }
@keyframes drift{ 0%{--x:12%;--y:18%} 50%{--x:78%;--y:72%} 100%{--x:12%;--y:18%} }

/* Cells */
.cell{ width:var(--cell-size); height:var(--cell-size); border-radius:14px; position:relative; overflow:hidden; display:flex; align-items:center; justify-content:center;
  background:linear-gradient(180deg,#0c142a,#0a1020); border:1px solid #5a6b8b10; box-shadow:0 1px 0 #ffffff08 inset, 0 -1px 0 #000000aa inset, 0 6px 18px #0008;
  cursor:pointer; transition:transform .06s ease, box-shadow .2s ease, outline-color .2s ease; outline:2px solid #ffffff14; }
.cell:active{transform:scale(.985)}
.cell.owned{ box-shadow: 0 0 0 1px #ffffff12 inset, 0 0 18px var(--neon,#00f) inset, 0 0 22px var(--neon,#00f), 0 12px 26px #000a;
  outline:2px solid color-mix(in srgb, var(--neon,#00f) 50%, transparent); }

/* Orbs */
.orb{width:62%; height:62%; border-radius:999px; position:relative; display:grid; place-items:center; filter: drop-shadow(0 2px 6px rgba(0,0,0,.6)); transition: transform .15s ease;}
.orb::after{content:""; width:36%; height:36%; background:#fff9; border-radius:999px; position:absolute; top:18%; left:18%; filter:blur(1px)}
.orb.count2{width:80%; height:80%; display:flex; gap:12%}
.orb.count2>i,.orb.count3>i{display:block; width:42%; height:42%; background:#fff3; border-radius:999px}
.orb.count3{width:92%; height:92%; display:flex; gap:6%; align-items:center; justify-content:center}
.orb.count3>i{width:32%; height:32%}

/* Bomb */
.bomb{ position:absolute; inset:auto auto 6% 6%; width:26%; aspect-ratio:1/1; display:block;
  filter: drop-shadow(0 0 6px currentColor) drop-shadow(0 0 12px currentColor); animation: bombPulse 1s ease-in-out infinite; opacity:.95; }
@keyframes bombPulse{ 0%,100%{transform:scale(1)} 50%{transform:scale(1.15)} }

/* Footer */
.footer{color:var(--muted); margin:16px 0 4px; font-size:13px}

@media (max-width:520px){ :root{ --gap:8px; --cell-size:min(12vmin,52px);} .controls{gap:6px 8px} select,.btn{padding:8px} .colors{gap:8px} }
</style>
</head>
<body>
  <header class="topbar">
    <div class="brand">Chain Reaction — Neon (Online)</div>
    <div class="controls">
      <label>Players:
        <select id="playersSelect" aria-label="Number of players">
          <option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>7</option><option>8</option>
        </select>
      </label>
      <label>Grid:
        <select id="gridSelect" aria-label="Grid size">
          <option value="9x6">9×6</option>
          <option value="10x8">10×8</option>
          <option value="12x8">12×8</option>
          <option value="15x10">15×10</option>
        </select>
      </label>
      <button id="newGameBtn" class="btn">New Game</button>
      <button id="undoBtn" class="btn" title="Undo last full move">Undo</button>
    </div>
  </header>

  <main class="wrap">
    <div class="status">
      <div id="turnBadge" class="badge"></div>
      <div id="statusText" class="status-text">Tap a cell to play.</div>
    </div>

    <!-- ONLINE CONTROLS -->
    <div class="row">
      <button id="createRoomBtn" class="btn">Create Room</button>
      <input id="roomCodeInput" type="text" placeholder="Room code" />
      <button id="joinRoomBtn" class="btn">Join Room</button>
      <label>Seat:
        <select id="seatSelect">
          <option value="">—</option>
          <option value="1">P1</option><option value="2">P2</option><option value="3">P3</option><option value="4">P4</option>
          <option value="5">P5</option><option value="6">P6</option><option value="7">P7</option><option value="8">P8</option>
        </select>
      </label>
      <button id="copyLinkBtn" class="btn">Copy Link</button>
      <span id="roomStatus" style="color:#9bd1ff; font-size:14px"></span>
    </div>

    <!-- Player color controls -->
    <div id="colorPanel" class="colors">
      <div class="row">
        <strong style="font-size:14px;color:#d9e6ff">Player Colors</strong>
        <button id="resetColorsBtn" class="btn" style="margin-left:8px">Reset</button>
      </div>
      <div id="swatches" class="row"></div>
    </div>

    <div id="board" class="board" role="grid" aria-label="Board"></div>

    <footer class="footer">
      <div>Tip: A <b>bomb</b> appears when a cell is one step from exploding (capacity − 1). Corners explode at 2, edges at 3, center at 4. Online: create/join room, claim seats, then play.</div>
    </footer>
  </main>

  <!-- Firebase (compat builds) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <script>
(() => {
  const $ = s => document.querySelector(s);
  const el = (tag, cls, attrs={}) => { const n=document.createElement(tag); if(cls) n.className=cls; for(const[k,v] of Object.entries(attrs)) n.setAttribute(k,v); return n; };

  /* Colors */
  const DEFAULTS = ["#ff2d55","#2ea8ff","#2ed573","#ffb020","#b57aff","#ffd54a","#6cb2ff","#ff6b81"];
  let COLORS = [...DEFAULTS];
  const KEY = "cr_neon_colors";
  function loadColors(){ try{ const saved=JSON.parse(localStorage.getItem(KEY)); if(Array.isArray(saved)&&saved.length===8) COLORS=saved; }catch{} }
  function saveColors(){ try{ localStorage.setItem(KEY, JSON.stringify(COLORS)); }catch{} }

  /* Local State */
  let rows=6, cols=9, players=2, current=0, board=[], playing=true;
  let moveHistory=[], turnCommitted=false, eliminated=new Set(), firstMoveDone=new Array(8).fill(false);
  let movesMade = 0;                 // ✅ guard: no win checks before a real move
  let seatedCount = 0;               // ✅ how many seats are actually claimed
  let lobbyReady = false;            // ✅ becomes true when seatedCount >= min(2, players)

  /* ONLINE State */
  const clientId = (()=>{ const k="cr_client_id"; let v=localStorage.getItem(k); if(!v){ v=Math.random().toString(36).slice(2,10); localStorage.setItem(k,v);} return v; })();
  let roomId = ""; let mySeat = ""; let applyingRemote = false;

  /* DOM */
  const boardEl=$("#board"), statusText=$("#statusText"), turnBadge=$("#turnBadge"),
        playersSelect=$("#playersSelect"), gridSelect=$("#gridSelect"),
        newGameBtn=$("#newGameBtn"), undoBtn=$("#undoBtn"),
        swatchesEl=$("#swatches"), resetBtn=$("#resetColorsBtn"),
        createRoomBtn=$("#createRoomBtn"), joinRoomBtn=$("#joinRoomBtn"), roomInput=$("#roomCodeInput"),
        seatSelect=$("#seatSelect"), copyLinkBtn=$("#copyLinkBtn"), roomStatus=$("#roomStatus");

  /* Firebase init — your Singapore DB URL */
  const firebaseConfig = {
    apiKey: "AIzaSyCqmSa4u0Pmv2ubhVrATy_0_oaKfHYd1DM",
    authDomain: "chain-reaction-nikhil.firebaseapp.com",
    databaseURL: "https://chain-reaction-nikhil-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "chain-reaction-nikhil",
    storageBucket: "chain-reaction-nikhil.firebasestorage.app",
    messagingSenderId: "962407013979",
    appId: "1:962407013979:web:61aa487b08c4be9434697e",
    measurementId: "G-JBNJGW0K74"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  /* Helpers */
  function capacity(x,y){ const onTop=y===0,onBottom=y===rows-1,onLeft=x===0,onRight=x===cols-1; const edges=[onTop,onBottom,onLeft,onRight].filter(Boolean).length; return edges===2?2:edges===1?3:4; }
  function neighbors(x,y){ const n=[]; if(x>0)n.push([x-1,y]); if(x<cols-1)n.push([x+1,y]); if(y>0)n.push([x,y-1]); if(y<rows-1)n.push([x,y+1]); return n; }
  function deepCopyBoard(b){ return b.map(row=>row.map(c=>({owner:c.owner,count:c.count}))); }
  function serializeState(){ return { rows, cols, players, current, board, playing, firstMoveDone, eliminated:[...eliminated], movesMade }; }
  function applyState(s){
    rows=s.rows; cols=s.cols; players=s.players; current=s.current; board=s.board; playing=s.playing;
    firstMoveDone=s.firstMoveDone||new Array(8).fill(false); eliminated=new Set(s.eliminated||[]);
    movesMade = s.movesMade||0;
    setupBoard(cols,rows,false); renderBoard(); updateStatus("[Synced]");
  }
  function randomRoomCode(){ return Math.random().toString(36).toUpperCase().replace(/[^A-Z0-9]/g,"").slice(0,6); }

  /* UI Bindings */
  function bindUI(){
    newGameBtn.addEventListener("click", hostReset);
    undoBtn.addEventListener("click", undo);

    playersSelect.addEventListener("change", e=>{
      players=parseInt(e.target.value,10); setupColorPanel(); updateLobbyGuard();
      if(roomId) pushMeta();
    });

    gridSelect.addEventListener("change", e=>{
      const [c,r]=e.target.value.split("x").map(n=>parseInt(n,10)); cols=c; rows=r;
      resetBoardOnly(); if(roomId) pushState();
    });

    resetBtn.addEventListener("click", ()=>{
      COLORS=[...DEFAULTS]; saveColors(); setupColorPanel(); renderBoard(); updateStatus("Colors reset.");
      if(roomId) colorsRef(roomId).set(COLORS);
    });

    createRoomBtn.addEventListener("click", createRoom);
    joinRoomBtn.addEventListener("click", ()=>{ const code=(roomInput.value||"").trim().toUpperCase(); if(!code){ pulseStatus("Enter a room code."); return; } joinRoom(code); });
    copyLinkBtn.addEventListener("click", ()=>{ if(!roomId){ pulseStatus("Create or join a room first.", true); return; } const url=`${location.origin}${location.pathname}?room=${roomId}`; navigator.clipboard.writeText(url).then(()=>pulseStatus("Join link copied!")).catch(()=>pulseStatus(url)); });
    seatSelect.addEventListener("change", e=> claimSeat(e.target.value));
  }

  /* Reset / Setup */
  function resetBoardOnly(){
    current=0; playing=true; moveHistory=[]; firstMoveDone=new Array(8).fill(false); eliminated.clear(); movesMade=0;
    setupBoard(cols,rows,true); renderBoard(); updateStatus("New game ready. Player 1 starts.");
  }
  function hostReset(){
    // Anyone can press, but it resets for all
    resetBoardOnly();
    if(roomId) pushState();
  }
  function setupBoard(c,r,rebuildDOM=true){
    board=Array.from({length:r},()=>Array.from({length:c},()=>({owner:-1,count:0})));
    if(rebuildDOM){
      boardEl.innerHTML="";
      boardEl.style.gridTemplateColumns=`repeat(${c}, var(--cell-size))`;
      boardEl.style.gridTemplateRows=`repeat(${r}, var(--cell-size))`;
      for(let y=0;y<r;y++){
        for(let x=0;x<c;x++){
          const cell=el("button","cell",{"data-x":x,"data-y":y,"role":"gridcell"});
          cell.addEventListener("click",()=>handleMove(x,y));
          boardEl.appendChild(cell);
        }
      }
    } else {
      Array.from(boardEl.children).forEach(cell=>{ cell.classList.remove("owned"); cell.style.removeProperty("--neon"); cell.innerHTML=""; });
    }
  }

  /* Color UI */
  function setupColorPanel(){
    const swatchesEl=$("#swatches"); swatchesEl.innerHTML="";
    for(let i=0;i<players;i++){
      const wrap=el("div","swatch");
      const dot=el("span","dot"); dot.style.color=COLORS[i];
      const label=el("label",""); label.textContent=`P${i+1}`;
      const input=el("input","",{type:"color", value:COLORS[i]});
      input.addEventListener("input",(e)=>{ COLORS[i]=e.target.value; dot.style.color=COLORS[i]; saveColors(); renderBoard(); updateStatus(); if(roomId) colorsRef(roomId).set(COLORS); });
      wrap.append(dot,label,input); swatchesEl.appendChild(wrap);
    }
  }

  /* Rendering */
  function bombSVG(color){
    const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
    svg.setAttribute("viewBox","0 0 64 64"); svg.classList.add("bomb"); svg.style.color=color;
    const g = document.createElementNS(svg.namespaceURI,"g");
    const body = document.createElementNS(svg.namespaceURI,"circle"); body.setAttribute("cx","34"); body.setAttribute("cy","38"); body.setAttribute("r","18"); body.setAttribute("fill","currentColor");
    const neck = document.createElementNS(svg.namespaceURI,"rect"); neck.setAttribute("x","25"); neck.setAttribute("y","16"); neck.setAttribute("width","18"); neck.setAttribute("height","8"); neck.setAttribute("rx","3"); neck.setAttribute("fill","currentColor");
    const fuse = document.createElementNS(svg.namespaceURI,"path"); fuse.setAttribute("d","M44 18 C54 8, 62 16, 56 22"); fuse.setAttribute("stroke","currentColor"); fuse.setAttribute("stroke-width","4"); fuse.setAttribute("fill","none"); fuse.setAttribute("stroke-linecap","round");
    const spark = document.createElementNS(svg.namespaceURI,"circle"); spark.setAttribute("cx","56"); spark.setAttribute("cy","22"); spark.setAttribute("r","4"); spark.setAttribute("fill","currentColor");
    g.append(body,neck,fuse,spark); svg.appendChild(g); return svg;
  }
  function drawCellContent(cellEl,x,y){
    const data=board[y][x]; cellEl.innerHTML="";
    const owner=data.owner; const neon=owner!==-1 ? COLORS[owner%COLORS.length] : null;
    if(neon){ cellEl.classList.add("owned"); cellEl.style.setProperty("--neon",neon); } else { cellEl.classList.remove("owned"); cellEl.style.removeProperty("--neon"); }
    if(data.count===0){ cellEl.style.boxShadow="0 6px 18px #0008"; return; }
    const color = COLORS[owner%COLORS.length];
    if(data.count===1){ const o=el("div","orb"); o.style.background=color; cellEl.appendChild(o); }
    else if(data.count===2){ const w=el("div","orb count2"); w.style.background=color+"00"; w.appendChild(el("i")); w.appendChild(el("i")); cellEl.appendChild(w); }
    else { const w=el("div","orb count3"); w.style.background=color+"00"; w.appendChild(el("i")); w.appendChild(el("i")); w.appendChild(el("i")); cellEl.appendChild(w); }
    const cap=capacity(x,y); if(data.count===cap-1) cellEl.appendChild(bombSVG(color));
  }
  function renderCell(x,y){ const idx=y*cols+x; drawCellContent(boardEl.children[idx],x,y); }
  function renderBoard(){ const cells=boardEl.children; let i=0; for(let y=0;y<rows;y++) for(let x=0;x<cols;x++) drawCellContent(cells[i++],x,y); }

  /* Animations */
  function animatePlace(x,y){ renderCell(x,y); const orb=boardEl.children[y*cols+x].querySelector(".orb,.orb.count2,.orb.count3"); if(!orb) return;
    orb.style.transform="scale(0.82)"; requestAnimationFrame(()=>{ orb.style.transition="transform .15s ease"; orb.style.transform="scale(1)"; setTimeout(()=> orb.style.transition="",160); }); }
  function animateBlast(x,y){ const cellEl=boardEl.children[y*cols+x]; cellEl.animate([{transform:"scale(1)"},{transform:"scale(0.93)"},{transform:"scale(1)"}],{duration:170,easing:"ease-out"}); }

  /* Logic */
  function saveSnapshot(){ moveHistory.push({board:deepCopyBoard(board), current, playing, eliminated:new Set(Array.from(eliminated)), firstDone:[...firstMoveDone], movesMade}); if(moveHistory.length>30) moveHistory.shift(); }
  function undo(){
    if(!moveHistory.length) return;
    const s=moveHistory.pop();
    board=deepCopyBoard(s.board); current=s.current; playing=s.playing; eliminated=new Set(Array.from(s.eliminated)); firstMoveDone=[...s.firstDone]; movesMade=s.movesMade||movesMade;
    renderBoard(); updateStatus("Undid last move."); if(roomId) pushState();
  }
  function alivePlayers(){
    const counts=new Array(players).fill(0);
    for(let y=0;y<rows;y++) for(let x=0;x<cols;x++){ const c=board[y][x]; if(c.owner!==-1) counts[c.owner]+=c.count; }
    const alive=[]; for(let p=0;p<players;p++){ if(!firstMoveDone[p] || counts[p]>0) alive.push(p); } return alive;
  }
  function checkEliminations(){
    const counts=new Array(players).fill(0);
    for(let y=0;y<rows;y++) for(let x=0;x<cols;x++){ const c=board[y][x]; if(c.owner!==-1) counts[c.owner]+=c.count; }
    for(let p=0;p<players;p++){ if(firstMoveDone[p] && counts[p]===0) eliminated.add(p); }
  }
  function nextPlayer(){ for(let i=1;i<=players;i++){ const cand=(current+i)%players; if(!eliminated.has(cand)){ current=cand; break; } } }

  async function resolveReactions(){
    const q=[]; for(let y=0;y<rows;y++) for(let x=0;x<cols;x++) if(board[y][x].count>=capacity(x,y)) q.push([x,y]);
    if(!q.length){ renderBoard(); return; }
    const sleep=ms=>new Promise(res=>setTimeout(res,ms));
    while(q.length){
      const wave=[...new Set(q.map(([x,y])=>`${x},${y}`))].map(s=>s.split(",").map(n=>parseInt(n,10)));
      q.length=0; const toAdd=[];
      for(const [x,y] of wave){
        const cap=capacity(x,y), cell=board[y][x]; if(cell.count<cap) continue;
        cell.count-=cap; if(cell.count===0) cell.owner=-1; animateBlast(x,y);
        for(const [nx,ny] of neighbors(x,y)){ const ncell=board[ny][nx]; ncell.owner=current; ncell.count+=1; toAdd.push([nx,ny]); }
      }
      renderBoard();
      for(const [nx,ny] of toAdd) if(board[ny][nx].count>=capacity(nx,ny)) q.push([nx,ny]);
      await sleep(170);
    }
  }

  /* Guarded move handler to prevent instant-win */
  function canPlayNow(){
    // Require enough seats for a match and board synced once
    return lobbyReady && playing;
  }

  function handleMove(x,y){
    if(!canPlayNow()){ pulseStatus("Wait until both seats are claimed and New Game is pressed."); return; }

    // Online turn/seat
    if(roomId){
      if(!mySeat){ pulseStatus("Claim a seat (P1–P8) to play.", true); return; }
      const myIdx=parseInt(mySeat,10)-1;
      if(current!==myIdx){ pulseStatus("Not your turn.", true); return; }
    }

    const cell=board[y][x];
    if(cell.owner!==-1 && cell.owner!==current){ pulseStatus("Play on empty or your own cells.",true); return; }

    if(!turnCommitted){ saveSnapshot(); turnCommitted=true; }

    cell.owner=current; cell.count+=1; animatePlace(x,y);

    resolveReactions().then(()=>{
      movesMade += 1;                             // ✅ first real move happened
      if(!firstMoveDone[current]) firstMoveDone[current]=true;
      if (lobbyReady && movesMade>0){             // ✅ guard win checks
        checkEliminations();
        const alive=alivePlayers();
        if(alive.length===1){
          playing=false; updateStatus(`Player ${alive[0]+1} wins! 🏆`);
          turnCommitted=false; if(roomId) pushState(); return;
        }
      }
      nextPlayer(); turnCommitted=false; updateStatus();
      if(roomId) pushState();
    });
  }

  /* Status */
  function updateStatus(extra){
    const color=COLORS[current%COLORS.length]; turnBadge.style.background=color;
    const alive=alivePlayers().map(p=>p+1).join(", ");
    const lobbyMsg = lobbyReady ? "" : " • Waiting for seats / New Game";
    statusText.textContent = (roomId?`[${roomId}] `:"") + (extra || `Player ${current+1}'s turn • Alive: [${alive}]`) + (mySeat?` • You: P${mySeat}`:"") + lobbyMsg;
  }
  function pulseStatus(msg,warn=false){ statusText.textContent=msg; statusText.animate([{opacity:.6},{opacity:1}],{duration:260,easing:"ease-out"}); if(warn){ statusText.style.color="#ffb3b3"; setTimeout(()=> statusText.style.color="#9fb3c8",500); } }

  /* Firebase refs */
  const roomRef  = id => db.ref(`rooms/${id}`);
  const stateRef = id => db.ref(`rooms/${id}/state`);
  const seatsRef = id => db.ref(`rooms/${id}/seats`);
  const colorsRef= id => db.ref(`rooms/${id}/colors`);
  const metaRef  = id => db.ref(`rooms/${id}/meta`); // players/rows/cols snapshot

  /* Online helpers */
  function pushState(){ if(!roomId) return; applyingRemote=true; stateRef(roomId).set(serializeState()).finally(()=> setTimeout(()=> applyingRemote=false, 60)); }
  function pushMeta(){ if(!roomId) return; metaRef(roomId).set({players, rows, cols}); }

  function attachListeners(){
    // State sync
    stateRef(roomId).on("value", snap=>{
      const s=snap.val(); if(!s) return;
      if(applyingRemote) return;
      applyState(s);
    });
    // Seats sync
    seatsRef(roomId).on("value", snap=>{
      const seats=snap.val()||{};
      const taken=new Set(Object.keys(seats).filter(k=>seats[k]));
      seatedCount = taken.size;
      for(const opt of seatSelect.options){
        if(!opt.value) continue;
        opt.disabled = taken.has(opt.value) && seats[opt.value] !== clientId;
      }
      updateLobbyGuard();
    });
    // Colors sync
    colorsRef(roomId).on("value", snap=>{
      const c=snap.val();
      if(Array.isArray(c)&&c.length===8){ COLORS=c; setupColorPanel(); renderBoard(); updateStatus("[Colors synced]"); }
    });
    // Meta sync
    metaRef(roomId).on("value", snap=>{
      const m=snap.val(); if(!m) return;
      // follow host's settings
      if(typeof m.players==="number"){ players=m.players; playersSelect.value=String(players); setupColorPanel(); }
      if(typeof m.rows==="number" && typeof m.cols==="number"){ rows=m.rows; cols=m.cols; setupBoard(cols,rows,true); renderBoard(); }
      updateLobbyGuard();
    });
  }

  function updateLobbyGuard(){
    const needed = Math.min(2, players); // at least 2 to start
    lobbyReady = seatedCount >= needed;
    updateStatus(lobbyReady ? "[Lobby ready]" : "[Waiting for players]");
  }

  function createRoom(){
    const id=randomRoomCode(); roomId=id; mySeat=""; seatSelect.value="";
    const [c,r]=gridSelect.value.split("x").map(n=>parseInt(n,10)); cols=c; rows=r; players=parseInt(playersSelect.value,10);
    resetBoardOnly();
    // create room package
    roomRef(id).set({
      createdAt: Date.now(),
      meta: { players, rows, cols },
      seats: {},
      colors: COLORS,
      state: serializeState()
    }).then(()=>{
      attachListeners(); pushMeta();
      roomStatus.textContent=`Room ${id} created. Share the code or link.`; updateStatus("Room created.");
    }).catch(()=> pulseStatus("Room create failed.", true));
  }

  function joinRoom(id){
    roomId=id.toUpperCase(); mySeat=""; seatSelect.value="";
    attachListeners();
    roomStatus.textContent=`Joined ${roomId}. Claim a seat to play.`; updateStatus("[Joined]");
  }

  function claimSeat(n){
    if(!roomId || !n) return;
    const ref = seatsRef(roomId).child(n);
    ref.transaction(curr => (!curr || curr===clientId) ? clientId : curr,
      (err, committed, snap)=>{
        if(err){ pulseStatus("Seat claim error.",true); return; }
        const val=snap.val();
        if(val===clientId){ mySeat=n; updateStatus(`You took seat P${n}`); }
        else { pulseStatus("Seat already taken.", true); seatSelect.value=""; }
      });
    ref.onDisconnect().remove();
  }

  /* Init */
  function init(){
    loadColors(); playersSelect.value="2"; gridSelect.value="9x6";
    setupColorPanel(); setupBoard(cols,rows); bindUI(); updateStatus("Ready.");
    const params=new URLSearchParams(location.search); const r=(params.get("room")||"").toUpperCase(); if(r){ roomInput.value=r; joinRoom(r); }
  }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init); else init();
})();
  </script>
</body>
</html>
